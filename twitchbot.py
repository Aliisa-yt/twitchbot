"""Twitchbot: Translation and TTS bot for Twitch streaming.

This module provides the main entry point for the Twitchbot application. It handles
"""

from __future__ import annotations

import argparse
import asyncio
import signal
import sys
import tempfile
from pathlib import Path
from typing import TYPE_CHECKING, Final, NoReturn

from config.loader import (
    Config,
    ConfigLoader,
    ConfigLoaderError,
)
from core.bot import Bot
from core.token_manager import TokenManager, TwitchBotToken
from core.version import VERSION
from handlers.katakana import E2KConverter, Romaji
from utils.file_utils import FileUtils
from utils.logger_utils import LoggerUtils

if TYPE_CHECKING:
    import logging

CFG_FILE: Final[str] = "twitchbot.ini"
LOG_FILE: Final[str] = "debug.log"
TOKEN_CACHE_FILE: Final[str] = "tokens.json"

logger: logging.Logger = LoggerUtils.get_logger(__name__)


def check_python_version() -> None:
    # Must be run on version 3.13 or later to use features implemented in Python 3.13.
    if sys.version_info < (3, 13):
        msg = "Python 3.13 or later is required"
        raise RuntimeError(msg)


def sig_handler(signum, frame) -> None:  # noqa: ARG001
    _ = signum, frame
    # signals not generated by Windows
    raise KeyboardInterrupt


class _ArgumentParser(argparse.ArgumentParser):
    def error(self, message: str) -> NoReturn:
        print(f"\n{message}\n", file=sys.stderr)
        self.print_help(sys.stderr)
        raise SystemExit(2)


def parse_arguments() -> argparse.Namespace:
    """Parse command-line arguments for owner and bot names."""
    parser = _ArgumentParser()
    parser.add_argument("--owner", dest="owner", metavar="OWNER_NAME", help="Override channel owner name")
    parser.add_argument("--bot", dest="bot", metavar="BOT_NAME", help="Override bot user name")
    parser.add_argument("-d", "--debug", action="store_true", help="Enable debug mode")
    return parser.parse_args()


def load_config() -> Config:
    """Load configuration file."""

    script_name: str = Path(sys.argv[0]).stem
    # Parse command-line arguments
    args: argparse.Namespace = parse_arguments()
    cfg: Config = ConfigLoader(config_filename=CFG_FILE, script_name=script_name, **vars(args)).config
    cfg.GENERAL.VERSION = VERSION
    cfg.GENERAL.SCRIPT_NAME = script_name
    return cfg


def load_dictionary(config: Config) -> None:
    """Load various conversion dictionaries."""
    dic_base: Path = FileUtils.resolve_path(config.DICTIONARY.PATH)
    if config.TTS.KATAKANAISE:
        Romaji.load(Path.joinpath(dic_base, config.DICTIONARY.ROMAJI_DIC))
        for dic_name in config.DICTIONARY.KATAKANA_DIC:
            E2KConverter.load(Path.joinpath(dic_base, dic_name))


class SignalHandler:
    def __init__(self, sig: signal._SIGNUM, handler: signal._HANDLER) -> None:
        self.sig = sig
        self.handler = handler
        self.original_handler: signal._HANDLER | None = None

    def __enter__(self) -> None:
        self.original_handler = signal.signal(self.sig, self.handler)

    def __exit__(self, exc_type, exc_value, traceback) -> None:
        _ = exc_type, exc_value, traceback
        signal.signal(self.sig, self.original_handler)


async def main() -> None:
    check_python_version()
    log_setup = LoggerUtils(filename=FileUtils.resolve_path(LOG_FILE))
    logger.info("Process started")

    with SignalHandler(signal.SIGTERM, sig_handler):
        config: Config = load_config()
        if config.GENERAL.DEBUG:
            log_setup.set_level("DEBUG")
            logger.warning("======== Launch in Debug Mode ========")

        with tempfile.TemporaryDirectory(prefix="tmp_", dir=Path.cwd()) as tmpdirname:
            config.GENERAL.TMP_DIR = FileUtils.resolve_path(tmpdirname)
            logger.info("generated temporary directory '%s'", config.GENERAL.TMP_DIR)

            # Load various conversion dictionaries
            load_dictionary(config)
            logger.info("loaded dictionary files")

            # Start authorization flow and get tokens
            _token_manager: TokenManager = TokenManager(FileUtils.resolve_path(TOKEN_CACHE_FILE))
            token_data: TwitchBotToken = await _token_manager.start_authorization_flow(
                config.TWITCH.OWNER_NAME, config.BOT.BOT_NAME
            )

            # Display version on console
            print(f"twitchbot ver.{config.GENERAL.VERSION}")
            async with Bot(config, token_data) as bot:
                await bot.start(with_adapter=False)


if __name__ == "__main__":
    shutdown_status: bool = False
    try:
        asyncio.run(main())
    except (ValueError, OSError) as err:
        logger.critical(err)
    except RuntimeError as err:
        logger.critical("RuntimeError: %s", err)
    except ConfigLoaderError as err:
        logger.error("An error occurred in ConfigLoader: '%s'", err)
    except KeyboardInterrupt:
        logger.debug("KeyboardInterrupt received, shutting down gracefully")
        # Set to 'True' when a normal termination occurs.
        shutdown_status = True
    finally:
        # If the process is not terminated by a signal, wait for user input before exiting.
        if not shutdown_status:
            input("Press Enter to exit...")
        logger.info("Process finished successfully")
