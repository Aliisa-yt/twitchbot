"""Twitchbot: Translation and TTS bot for Twitch streaming.

This module provides the main entry point for the Twitchbot application. It handles
GUI initialization, configuration loading, token verification, and bot startup.
"""

from __future__ import annotations

import argparse
import asyncio
import signal
import sys
import tempfile
from contextlib import suppress
from pathlib import Path
from typing import TYPE_CHECKING, Final, NoReturn

from config.loader import (
    Config,
    ConfigLoader,
    ConfigLoaderError,
)
from core.bot import Bot
from core.token_manager import TokenManager, TwitchBotToken
from core.token_storage import TokenStorage
from core.version import VERSION
from handlers.katakana import E2KConverter, Romaji
from utils.file_utils import FileUtils
from utils.gui_app import (
    STATUS_RUNNING_COLOR,
    STATUS_WAKEUP_COLOR,
    GUIApp,
)
from utils.logger_utils import LoggerUtils

if TYPE_CHECKING:
    import logging

CFG_FILE: Final[str] = "twitchbot.ini"
LOG_FILE: Final[str] = "debug.log"
TOKEN_DB_FILE: Final[str] = "tokens.db"

logger: logging.Logger = LoggerUtils.get_logger(__name__)


def check_python_version() -> None:
    # Must be run on version 3.13 or later to use features implemented in Python 3.13.
    if sys.version_info < (3, 13):
        msg = "Python 3.13 or later is required"
        raise RuntimeError(msg)


def is_bundled_executable() -> bool:
    """Check if the application is running as a bundled executable."""
    return getattr(sys, "frozen", False) and hasattr(sys, "_MEIPASS")


def sig_handler(signum, frame) -> None:
    _ = signum, frame
    # signals not generated by Windows
    raise KeyboardInterrupt


class _ArgumentParser(argparse.ArgumentParser):
    def error(self, message: str) -> NoReturn:
        print(f"\n{message}\n", file=sys.stderr)
        self.print_help(sys.stderr)
        raise SystemExit(2)


def parse_arguments() -> argparse.Namespace:
    """Parse command-line arguments for owner and bot names."""
    parser = _ArgumentParser()
    parser.add_argument("--owner", dest="owner", metavar="OWNER_NAME", help="Override channel owner name")
    parser.add_argument("--bot", dest="bot", metavar="BOT_NAME", help="Override bot user name")
    parser.add_argument("-d", "--debug", action="store_true", help="Enable debug mode")
    parser.add_argument("-g", "--gui", action="store_true", help="Launch with GUI interface")
    parser.add_argument("--no-gui", dest="gui", action="store_false", help="Launch without GUI interface")
    parser.set_defaults(gui=True)
    return parser.parse_args()


def load_config(args: argparse.Namespace) -> Config:
    """Load configuration file."""

    script_name: str = Path(sys.argv[0]).stem
    cfg: Config = ConfigLoader(config_filename=CFG_FILE, script_name=script_name, **vars(args)).config
    cfg.GENERAL.VERSION = VERSION
    cfg.GENERAL.SCRIPT_NAME = script_name
    return cfg


def configure_logging(log_setup: LoggerUtils, config: Config) -> None:
    """Configure logging level from configuration."""
    if config.GENERAL.DEBUG:
        log_setup.set_level("DEBUG")
        logger.warning("======== Launch in Debug Mode ========")


def token_db_has_data(db_path: Path) -> bool:
    """Check whether the token database exists and contains token data.

    Performs file-based verification:
    1. File exists
    2. File size > 0 (not empty)
    3. Contains valid token data

    Args:
        db_path: Path to the token database file.

    Returns:
        bool: True if database exists and contains valid tokens, False otherwise.
    """
    if not db_path.exists():
        logger.debug("Token database does not exist: %s", db_path)
        return False
    if db_path.stat().st_size <= 0:
        logger.debug("Token database is empty: %s", db_path)
        return False

    try:
        storage = TokenStorage(db_path)
        with storage:
            tokens = storage.load_tokens()

        access_token: str = tokens.get("access_token", "")
        refresh_token: str = tokens.get("refresh_token", "")
        has_data: bool = bool(access_token and refresh_token)

        if not has_data:
            logger.debug("Token database missing required tokens")
    except OSError as err:
        logger.error("Error reading token database: %s", err)
        return False
    except (KeyError, ValueError) as err:
        logger.error("Error parsing token database: %s", err)
        return False
    else:
        return has_data

    return False


def show_token_setup_dialog(app: GUIApp) -> None:
    """Show a GUI dialog to instruct the user to run setup_tokens.py.

    Args:
        app: GUIApp instance for displaying the dialog.
    """
    if is_bundled_executable():
        message = (
            "The token has either not been acquired or has been reset.\n\n"
            "Please run the following command:\n"
            "  setup_tokens.exe [--owner <name>] [--bot <name>]"
        )
    else:
        message = (
            "The token has either not been acquired or has been reset.\n\n"
            "Please run the following command:\n"
            "  python setup_tokens.py [--owner <name>] [--bot <name>]"
        )
    app.show_error_dialog("Error", message)


def load_dictionary(config: Config) -> None:
    """Load various conversion dictionaries."""
    dic_base: Path = FileUtils.resolve_path(config.DICTIONARY.PATH)
    if config.TTS.KATAKANAISE:
        Romaji.load(Path.joinpath(dic_base, config.DICTIONARY.ROMAJI_DIC))
        for dic_name in config.DICTIONARY.KATAKANA_DIC:
            E2KConverter.load(Path.joinpath(dic_base, dic_name))


class SignalHandler:
    def __init__(self, sig: signal._SIGNUM, handler: signal._HANDLER) -> None:
        self.sig = sig
        self.handler = handler
        self.original_handler: signal._HANDLER | None = None

    def __enter__(self) -> None:
        self.original_handler = signal.signal(self.sig, self.handler)

    def __exit__(self, exc_type, exc_value, traceback) -> None:
        _ = exc_type, exc_value, traceback
        signal.signal(self.sig, self.original_handler)


async def _gui_bootstrap(app: GUIApp, args: argparse.Namespace, log_setup: LoggerUtils) -> None:
    """Bootstrap sequence for GUI mode.

    Args:
        app: GUIApp instance.
        args: Command-line arguments.
        log_setup: Logger utility instance.

    Raises:
        ConfigLoaderError: If configuration loading fails.
        RuntimeError: If token verification or bot initialization fails.
    """
    try:
        # Step 1: Load configuration
        app.update_status("Loading configuration...", STATUS_WAKEUP_COLOR)
        config: Config = load_config(args)
        configure_logging(log_setup, config)
        app.root.title(f"{config.GENERAL.SCRIPT_NAME} - ver. {config.GENERAL.VERSION}")
        logger.info("Configuration loaded")

        # Step 2: Verify token database (file-based check only)
        app.update_status("Verifying tokens...", STATUS_WAKEUP_COLOR)
        token_db_path: Path = FileUtils.resolve_path(TOKEN_DB_FILE)
        if not token_db_has_data(token_db_path):
            logger.error("Token database is missing or invalid: %s", token_db_path)
            show_token_setup_dialog(app)
            msg = "Token database is missing or invalid."
            raise RuntimeError(msg)
        logger.info("Token database verified")

        # Step 3: Load dictionaries
        app.update_status("Loading dictionaries...", STATUS_WAKEUP_COLOR)
        load_dictionary(config)
        logger.info("Dictionary files loaded")

        # Step 4: Load tokens and start bot
        app.update_status("Starting bot...", STATUS_WAKEUP_COLOR)
        token_manager: TokenManager = TokenManager(token_db_path)
        token_data: TwitchBotToken = await token_manager.start_authorization_flow(
            config.TWITCH.OWNER_NAME, config.BOT.BOT_NAME
        )

        print(f"twitchbot ver.{config.GENERAL.VERSION}")

        # Create temporary directory for TTS audio files
        with tempfile.TemporaryDirectory(prefix="tmp_", dir=Path.cwd()) as tmpdirname:
            config.GENERAL.TMP_DIR = FileUtils.resolve_path(tmpdirname)
            logger.info("Created temporary directory: %s", config.GENERAL.TMP_DIR)

            async with Bot(config, token_data) as bot:
                app.update_status("Bot running...", STATUS_RUNNING_COLOR)
                await bot.start(with_adapter=False)

    except ConfigLoaderError as err:
        logger.error("Configuration loading failed: %s", err)
        app.show_error_dialog("Configuration Error", f"Failed to load the configuration file.\n\nDetails: {err}")
        raise
    except RuntimeError as err:
        logger.error("Runtime error: %s", err)
        # Token error is already shown via show_token_setup_dialog
        if "Token database" not in str(err):
            app.show_error_dialog("Error", str(err))
        raise
    except (OSError, ValueError, TypeError) as err:
        logger.exception("Unexpected error during initialization")
        app.show_error_dialog("Error", f"An unexpected error occurred.\n\nDetails: {err}")
        raise


async def _console_bootstrap(args: argparse.Namespace, log_setup: LoggerUtils) -> None:
    """Bootstrap sequence for console mode.

    Args:
        args: Command-line arguments.
        log_setup: Logger utility instance.

    Raises:
        RuntimeError: If token verification fails.
    """
    config: Config = load_config(args)
    configure_logging(log_setup, config)

    token_db_path: Path = FileUtils.resolve_path(TOKEN_DB_FILE)
    if not token_db_has_data(token_db_path):
        msg = (
            "Token database is missing or invalid. Run 'python setup_tokens.py [--owner <name>] [--bot <name>]' first."
        )
        raise RuntimeError(msg)

    load_dictionary(config)
    logger.info("Dictionary files loaded")

    token_manager: TokenManager = TokenManager(token_db_path)
    token_data: TwitchBotToken = await token_manager.start_authorization_flow(
        config.TWITCH.OWNER_NAME, config.BOT.BOT_NAME
    )

    print(f"twitchbot ver.{config.GENERAL.VERSION}")

    with tempfile.TemporaryDirectory(prefix="tmp_", dir=Path.cwd()) as tmpdirname:
        config.GENERAL.TMP_DIR = FileUtils.resolve_path(tmpdirname)
        logger.info("Created temporary directory: %s", config.GENERAL.TMP_DIR)

        async with Bot(config, token_data) as bot:
            await bot.start(with_adapter=False)


async def main() -> None:
    """Main entry point for the application.

    Startup sequence:
    1. Check Python version
    2. Parse command-line arguments
    3. Initialize logging (file only)
    4. GUI mode: Create window early (if enabled)
    5. Load configuration
    6. Verify token database (file-based check)
    7. Load dictionaries
    8. Initialize bot
    9. Start bot (temporary directory created lazily by TTS manager)
    """
    check_python_version()

    # Parse arguments to check if GUI mode is enabled
    args: argparse.Namespace = parse_arguments()
    gui_mode: bool = bool(args.gui)

    log_setup = LoggerUtils(filename=FileUtils.resolve_path(LOG_FILE), use_null_console=gui_mode)
    logger.info("Process started")

    with SignalHandler(signal.SIGTERM, sig_handler):
        if gui_mode:
            # Create GUI window early (before loading config)
            app: GUIApp = GUIApp(window_title="Twitchbot")
            logger.info("GUI window created")
            await app.run_with_bot(_gui_bootstrap(app, args, log_setup))
        else:
            await _console_bootstrap(args, log_setup)


if __name__ == "__main__":
    # Track whether the application terminated normally.
    # If False, pause before exit to allow user to read error messages (console mode only).
    shutdown_status: bool = False
    try:
        asyncio.run(main())
        shutdown_status = True
    except (ValueError, OSError) as err:
        logger.critical(err)
    except RuntimeError as err:
        logger.critical("RuntimeError: %s", err)
    except ConfigLoaderError as err:
        logger.error("An error occurred in ConfigLoader: '%s'", err)
    except KeyboardInterrupt:
        logger.debug("KeyboardInterrupt received, shutting down gracefully")
        shutdown_status = True
    finally:
        # Pause before exit if abnormal termination occurred.
        # In GUI mode with --noconsole build, stdin is unavailable and EOFError is suppressed.
        # In console mode, this allows the user to read error messages before the window closes.
        if not shutdown_status:
            with suppress(KeyboardInterrupt, EOFError):
                input("Press Enter to exit...")
        logger.info("Process finished successfully")
